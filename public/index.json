
[{"content":"","date":"2026年2月6日","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" ","date":"2026年2月6日","externalUrl":null,"permalink":"/","section":"Daydream Nation","summary":" ","title":"Daydream Nation","type":"page"},{"content":"","date":"2026年2月6日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2026年2月6日","externalUrl":null,"permalink":"/tags/vim/","section":"Tags","summary":"","title":"Vim","type":"tags"},{"content":"","date":"2026年2月6日","externalUrl":null,"permalink":"/tags/%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/","section":"Tags","summary":"","title":"开发者工具","type":"tags"},{"content":"","date":"2026年2月6日","externalUrl":null,"permalink":"/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/","section":"Tags","summary":"","title":"生产力","type":"tags"},{"content":"","date":"2026年2月6日","externalUrl":null,"permalink":"/categories/%E9%9A%8F%E7%AC%94/","section":"Categories","summary":"","title":"随笔","type":"categories"},{"content":"","date":"2026年2月6日","externalUrl":null,"permalink":"/posts/","section":"文章","summary":"","title":"文章","type":"posts"},{"content":" Vim 禅修：从“肌肉记忆”到“思维流”的跨越 # 很多年后，当我习惯了在浏览网页甚至写邮件时都不自觉地敲下 j 和 k 时，我才意识到，Vim 对我来说已经不再是一个编辑器了。它更像是一种思维方式的延伸。\n初学者最常问的问题是：“为什么要花几周时间去背那些古怪的指令，就为了省下挪动鼠标的那一秒钟？”\n我的答案很简单：因为挪动鼠标会打断你的“流”（Flow）。\n这里的指令不是“背”的，是“说”的 # 如果你还在死记硬背 dw 是删除单词，c3w 是修改三个单词，那说明你还没跨过那道坎。\nVim 的核心逻辑是一套语法。它有动词（Verb）、有名词（Noun），甚至有形容词（Adjective）。\nd (Delete) 是动词。 w (Word) 是名词。 i (Inside) 是形容词。 当你敲下 diw 时，你不是在输入指令，你是在告诉编辑器：“Delete inside word”（删除这个单词）。这种“语言化”的操作逻辑，让你的大脑可以直接跳过“如何操作”的步骤，直达“我要做什么”。\n这很神奇。\n拒绝“帕金森式”的微调 # 回忆一下你用 VS Code 或者 IDE 的场景：你盯着屏幕，右手握着鼠标，试图精准地把光标点在那两个引号之间。点偏了，退一格，再点。\n这种反复的微调，是在消耗你的精神熵。\n在 Vim 里，我只需要 f\u0026quot;。光标会像猎犬一样瞬间咬住那个引号。这种确定性带来的安全感，是任何精密的鼠标都给不了的。\n插件陷阱与极简主义 # 我见过太多的新手，在还没搞明白 Ctrl-u 和 Ctrl-d 的区别时，就先装了 50 个插件。最后，他们的 Vim 变得像一辆贴满广告的二手车，沉重且易碎。\n我曾经历过那个阶段。后来，我删掉了大部分花哨的 UI，回到了原生配置。\n我发现，当你不再依赖那些闪烁的边框和弹窗时，你才能真正看清代码的结构。就像 Sonic Youth 的噪音摇滚——去掉那些华丽的修饰，剩下的反馈和节奏才是灵魂。\n结语：它不快，但它很准 # Vim 真的能让你写代码变快吗？或许吧。但在我看来，它最大的意义在于降噪。\n它减少了你从“产生想法”到“代码上屏”之间的阻力。它让你的手跟上了你的脑子。当你不再需要思考如何移动光标时，你才算真正开始了编程。\n如果你还没试过，去命令行敲一下 vimtutor 吧。\n或许就在某个瞬间，当你第一次成功地用 ci\u0026quot; 替换了括号里的内容时，你会感受到那种前所未有的自由。\n","date":"2026年2月6日","externalUrl":null,"permalink":"/posts/the-zen-of-vim/","section":"文章","summary":"为什么在 2026 年，我依然建议你放下鼠标，回到键盘的 Home Row？这不关乎效率，而关乎如何让编辑器跟上你的脑回路。","title":"我的Neovim配置","type":"posts"},{"content":"","date":"2026年2月6日","externalUrl":null,"permalink":"/tags/c%E8%AF%AD%E8%A8%80/","section":"Tags","summary":"","title":"C语言","type":"tags"},{"content":"","date":"2026年2月6日","externalUrl":null,"permalink":"/tags/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","section":"Tags","summary":"","title":"底层原理","type":"tags"},{"content":"","date":"2026年2月6日","externalUrl":null,"permalink":"/categories/%E6%8A%80%E6%9C%AF%E8%AF%A6%E8%A7%A3/","section":"Categories","summary":"","title":"技术详解","type":"categories"},{"content":"","date":"2026年2月6日","externalUrl":null,"permalink":"/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","section":"Tags","summary":"","title":"内存管理","type":"tags"},{"content":" 透视内存模型：别再让局部变量在栈里“借尸还魂” # 在 C 语言的工程实践里，我见过太多初学者掉进同一个坑：把数据类型和存储区域强行锁死。\n很多人觉得“栈空间就是数组，堆空间就是指针”。这种二元对立的理解模型，往往就是野指针和内存泄漏的温床。想要写出工业级的代码，我们必须剥离这些表象，直接去感知虚拟地址空间的物理律动。\n栈：高频交易的“瞬时工位” # 很多人把栈想象成容器，但我更倾向于把它看作一段动态执行的流。在 x86-64 架构下，操作栈极其廉价。说白了，它就是 rsp 寄存器的一场加减游戏。\n当编译器处理 sub rsp, 40 时，空间就划出来了；执行 add rsp, 40 时，空间瞬间收回。\n局部变量的生存悖论 # 你在函数里写下 int a[10]; 时，编译器其实并没创造什么东西，它只是算好了偏移量。我常说，栈帧里的变量其实是“活在当下”的。一旦函数执行到右花括号 }，汇编指令 leave 和 ret 就会无情地把 rsp 弹回。\n这片内存就此失效。\n因为栈内存是连续的，它极其讨好 CPU 的缓存机制。访问它的速度，通常是堆内存的数十倍。所以，栈是系统自动打理的“极速区”，我们不需要、也无权去插手它的生死。\n堆：手动经营的“持久化仓库” # 堆的操作逻辑完全不同。它不是线性增长的，而是一个由链表（或者红黑树）勉强维持秩序的内存池。\n当你调用 malloc(100) 时，内核正忙着处理复杂的交互。它要翻遍空闲链表，找出一块够大的空地，切分、贴上元数据标签，最后才把指针交给你。这很慢，但它给了你跨越函数边界的控制权。\nint* ptr = (int*)malloc(10 * sizeof(int)); 这行代码其实在内存里搭起了一座桥。\n栈这一头：存着 ptr 这个 8 字节的变量，函数没了它就没了。 堆那一头：躺着那 40 字节的实体，只要你不手动拆迁，它就永远在那。 这就是为什么我们必须 free。操作系统不会帮我们扫描堆内存。如果你丢了栈上的“钥匙”，却没锁上仓库的大门，这块内存就会变成进程里的幽灵，直到程序崩溃或结束。\n避坑：Return 之后的“幽灵数据” # 我曾不止一次在深夜调试时，对着返回局部变量地址导致的 Segfault 抓耳挠腮。\n场景 A：返回栈数组（自杀行为） # int* crash_func() { int nums[3] = {1, 2, 3}; return nums; } 这代码看起来没问题，但 nums 的命门在栈上。函数一返回，地址虽然还在 rax 里，但原先的内存区域已经被标记为“无人区”。你只要接着调用任何一个函数（哪怕是 printf），新的栈帧就会立刻覆盖这块地。\n这时候，你拿到的数据就是一堆随机乱码。\n场景 B：返回堆指针（唯一正途） # int* safe_func() { int* nums = (int*)malloc(3 * sizeof(int)); return nums; } 虽然栈上的 nums 变量消失了，但堆里的数据还在。调用者接过了这块内存的接力棒，也接过了最后 free 它的责任。\n结语：C 语言不相信安全气囊 # 栈与堆的选择，本质上是速度与自由的权衡。\n栈：自动、极速、但也短命。 堆：灵活、持久、但代价是繁琐的手动管理。 我给你的建议很简单：永远不要试图返回局部变量的地址，并且永远记得 malloc 之后的那句 free。在 C 的世界里，权利越大，责任越大。\n","date":"2026年2月6日","externalUrl":null,"permalink":"/posts/my-first-post/","section":"文章","summary":"深入探讨 C 语言中栈与堆的物理本质，解析局部变量的生存悖论与手动内存管理的底层逻辑。","title":"透视内存模型：别再让局部变量在栈里“借尸还魂”","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":" 在废墟中构建白日梦国度 # 你好。我是 Cigar。\n如果你在这里试图寻找一份标准的、完美的职场简历，那你可能找错地方了。这里更多的是关于噪音、反馈和未完成的代码。\n为什么是“赛博浪人”？ # 我沉迷于那些不完美的东西。比如 Sonic Youth 琴弦里刺耳的反馈，比如大卫·林奇电影里那些没有解释的梦境。\n在编程的世界里，我依然保持着这种“不适感”。我拒绝那些臃肿的 IDE，坚守在 Vim 的黑框里。对我来说，代码不只是逻辑的堆砌，它是一场与机器的角力。\n我关注什么 # 底层与逻辑：我喜欢去抠 C 语言里的内存模型，因为在那里，你才能感受到计算机的呼吸。 极简主义：无论是在文件系统还是现实生活，我都在试图剔除那些不必要的“噪音”。 创造的快感：无论是写一段脚本，还是拍一张照片，那种从无到有的过程让我着迷。 寻找反馈 # 生活本身就是一场巨大的反馈回路。\n如果你也喜欢在深夜调试 Bug，或者同样觉得 Daydream Nation 是人类文明的巅峰之一，欢迎给我发邮件：2013189697zsj@gmail.com。\n顺便说一句：Vim 的 HJKL 才是人类最自然的律动。\n","externalUrl":null,"permalink":"/about/","section":"Daydream Nation","summary":"在废墟中构建白日梦国度 # 你好。我是 Cigar。\n","title":"关于我","type":"page"}]